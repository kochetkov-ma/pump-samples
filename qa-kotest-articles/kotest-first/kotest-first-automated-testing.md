Kotlin. Автоматизация тестирования (часть 1). Kotest: Начало 
======

TODO:: Сюда картина Kotest

Более 5 лет занимаясь автоматизацией тестирования на Java я перепробовал множество подходов и технологий.
Начиналось все с 'голого' Junit + Selenium + RestAssured, вместо Junit пробовал TestNG, потом в стеке появились отчеты Allure.
Были и проекты, где использовались платные версии HP Unified Functional Testing, HP LeanFT, IBM Rational Functional. 
На замену Selenium пришел Selenoid, а для тестирования микро-сервисов TestContainers. Пробовал и Groovy Spock. 
Основная цель поисков — найти и доработать под себя один Фреймворк или несколько отдельных технологий и объединить в единый подход, который обеспечит:
- быстрый старт для нового QA
- хорошую документацию
- минимальную дублируемость кода
- читаемость кода тестов
- понятные отчеты о результате
- масштабируемость и надежность самого инструмента
- удобство работы большой командой или множеством мелких
- раньше была острая необходимость в параллельности, но сейчас в эпоху облачных ресурсов, контейнерезации и оркестрации это качество отодвинулось на второй план

До недавнего времени (и наверное остается по сей день для меня) оптимальный набор инструментов для организации автоматизации функционального e2e или интеграционного тестирования является такой набор:
1. BDD подход основанный на Cucumber
2. Отдельный проект отведенный под шаги со своими unit-тестами
3. Selenide + самописный PageFactory 
4. Retrofit для тестирования API
5. TestContainers для контроля отдельных контейнеров (либо клиент для Kubernetes)
6. Allure отчеты
7. Spring Core для DI, контроля областей видимости и конфигурирования
8. Spring Data JPA для взаимодействия с БД
9. Сборка всего этого дела Gradle-ом
> _**Естественно, это актуально для штата более 2-ух QA** Для меньших команд действуют совсем другие правила_ 

Этот набор позволяет писать feature файлы практически не работая с Java кодом — соответсвенно, проще найти QA специалиста подходящего уровня. 
А на роль поддержки / модификации и создания новых шагов достаточно нескольких разработчиков или сильный QA. 
Естественно у этого подхода есть определенные минусы и большинство знают о них (особенно ненавистники BDD) и эти минусы довольно существенны, хотя и приемлимы, если с ними правильно бороться. 

**А теперь к сути!** Очередной мой новый проект оказался на **Kotlin**, и передо мной встал выбор: продолжать следовать проверенной тактике или же немного 'переобуться' 
и попробовать писать тесты в виде кода используя довольно молодой Фреймворк, написанный на Kotlin для создания и запуска тестов **Kotest** (в прошлом Kotlin Test).
Ну и как не сложно догадаться выбор пал на второй вариант! В итоге, забегая вперед, сам **Kotest** и вариант стиля, который был выбран мне очень понравились по эффективности, лаконичности и простоте.
А так как обзоров и статей в принципе об автоматизации на **Kotlin** и **Kotest** в частности прямо скажем немного, то я посчитал хорошей идеей написать цикл статей про непосредственно использование самого Фреймворка, 
а также об организации проекта, сборке, запуске и сопутствующих технологиях. По итогу должен получится полноценный мануал — как создать систему или даже эко-систему автоматизации функционального тестирования на языке **Kotlin** и платформе **Kotest**.