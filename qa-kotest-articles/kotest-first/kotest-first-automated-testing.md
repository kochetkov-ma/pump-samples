Kotlin. Автоматизация тестирования (часть 1). Kotest: Начало 
======

TODO:: Сюда картина Kotest

Более 5 лет занимаясь автоматизацией тестирования на Java я перепробовал множество подходов и технологий.
Начиналось все с 'голого' Junit + Selenium + RestAssured, вместо Junit пробовал TestNG, потом в стеке появились отчеты Allure.
Были и проекты, где использовались платные версии HP Unified Functional Testing, HP LeanFT, IBM Rational Functional. 
На замену Selenium пришел Selenoid, а для тестирования микро-сервисов TestContainers. Пробовал и Groovy Spock. 
Основная цель поисков — найти и доработать под себя один Фреймворк или несколько отдельных технологий и объединить в единый подход, который обеспечит:
- быстрый старт для нового QA
- хорошую документацию
- минимальную дублируемость кода
- читаемость кода тестов
- понятные отчеты о результате
- масштабируемость и надежность самого инструмента
- удобство работы большой командой или множеством мелких
- раньше была острая необходимость в параллельности, но сейчас в эпоху облачных ресурсов, контейнерезации и оркестрации это качество отодвинулось на второй план

До недавнего времени (и наверное остается по сей день для меня) оптимальный набор инструментов для организации автоматизации функционального e2e или интеграционного тестирования является такой набор:
1. BDD подход основанный на Cucumber
2. Отдельный проект отведенный под шаги со своими unit-тестами
3. Selenide + самописный PageFactory 
4. Retrofit для тестирования API
5. TestContainers для контроля отдельных контейнеров (либо клиент для Kubernetes)
6. Allure отчеты
7. Spring Core для DI, контроля областей видимости и конфигурирования
8. Spring Data JPA для взаимодействия с БД
9. Сборка всего этого дела Gradle-ом
> _**Естественно, это актуально для штата более 2-ух QA** Для меньших команд действуют совсем другие правила_ 

Этот набор позволяет писать feature файлы практически не работая с Java кодом — соответсвенно, проще найти QA специалиста подходящего уровня. 
А на роль поддержки / модификации и создания новых шагов достаточно нескольких разработчиков или сильный QA. 
Естественно у этого подхода есть определенные минусы и большинство знают о них (особенно ненавистники BDD) и эти минусы довольно существенны, хотя и приемлимы, если с ними правильно бороться. 

**А теперь к сути!** Очередной мой новый проект оказался на **Kotlin**, и передо мной встал выбор: продолжать следовать проверенной тактике или же немного 'переобуться' 
и попробовать писать тесты в виде кода используя довольно молодой Фреймворк, написанный на Kotlin для создания и запуска тестов **Kotest** (в прошлом Kotlin Test).
Ну и как не сложно догадаться выбор пал на второй вариант! В итоге, забегая вперед, сам **Kotest** и вариант стиля, который был выбран мне очень понравились по эффективности, лаконичности и простоте.
А так как обзоров и статей в принципе об автоматизации на **Kotlin** и **Kotest** в частности прямо скажем немного, то я посчитал хорошей идеей написать цикл статей про непосредственно использование самого Фреймворка, 
а также об организации проекта, сборке, запуске и сопутствующих технологиях. По итогу должен получится полноценный мануал — как создать систему или даже эко-систему автоматизации функционального тестирования на языке **Kotlin** и платформе **Kotest**.

Минусы
------
Сходу определимся по глобальным минусам и учтем, что проект быстро развивается. Те проблемы, что есть в актуальной на время написания статьи версии `4.2.3` уже могут быть исправлены в свежих версиях.

И первым очевидным минусом является очень быстрое изменение минорных и мажорных версий. Еще в марте 2020 фреймворк назывался `KotlinTest`, и в 4 версии поменял название всех пакетов, потерял совместимость с плагином Idea и стал именоваться `Kotest`, а также стал мульти-платформенным.
При переходе с версии 4.0.7 на 4.1 перестали работать расширения, написанные для 4.0.7, а также сменились названия базовых модулей и много чего еще, то есть принцип семантического версионирования нарушился при переходе с `4.0` на `4.1`.
Это немыслимо для Java мира — это что-то из JS.
У инструмента пока небольшое комьюнити. 
В пользу широкого функционала иногда приносится в жертву продуманный дизайн. 
Не все предоставляемые стили написания тестов одинаково работают и отображаются в отчете. 
На текущий момент не корректно отображаются в отчетах data-driven и property-based тесты.
Шаблоны и фабрики тестов работают не как ожидается. 
Встроенное расширение allure совсем никуда не годится (к примеру, оно пытается обрабатывать аннотации, которыми в принципе невозможно аннотировать тестовые DSL методы).
Однако ни одного критического или блокирующего дефекта я не встречал.


Почему Kotest
------
Множество разработчиков на Kotlin не особо заморачиваются с выбором тестового фреймворка и продолжают использовать Junit4 или Junit5. 
Для них тесты — это как правило класс, помеченный аннотацией `@SpringBootTest` набор методов с аннотацией `@Test` возможно методы before и beforeClass с соответствующими аннотациями.
Для полноценных функциональных e2e тестов этого недостаточно. Наша цель — это написание понятных тестов на основе требований, удобная организация проверок, тестовых данных и отчетности.
Так вот `Kotest` позволяет:
- создавать крайне понятные тесты в BDD стиле с помощью Kotlin DSL и функций расширения,
- легко создавать data driven тесты в функциональном стиле
- также с помощью DSL определять действия перед тестом и тестовым классом и после них.
- определить действия на уровне всего прогона (фича, которой нет явно в junit)
- использовать встроенный крайне удобные assertions
- удобное конфигурирование тестовых классов и тестового проекта из кода
и много чего еще, см. [полную документацию](https://kotest.io/) и [сам проект в GitHub](https://github.com/kotest/kotest)  

Какой стиль выбрать? 
------
Kotest дает возможность выбора между несколькими вариантами DSL для формирования структуры тестов.
Самый базовый и простой [String Spec](https://kotest.io/styles/#string-spec) - идеально подойдет для написания unit-тестов с одним уровнем вложенности шагов.
Но нам нужно, что-то посложнее. 
Не буду долго рассуждать. 
Сразу скажу, что после долгих экспериментов я остановился на стиле [FreeSpec](https://kotest.io/styles/#free-spec).

#### Начинаем создавать тест
Используя `Kotest` я рекомендую продолжать писать тесты в BDD стиле, как в Cucumber. 
FreeStyle не накладывает ограничений на именование тестов, ключевые слова и вложенность, поэтому есть вещи нужно контролировать на уровне гайдов, обучения и Merge-Request`ов.

##### Иерархия тестовых сущностей
В нашем подходе будет 5 базовых тестовых сущностей (или уровней) в рамках Kotest. 
Важно определить это сейчас, потому что в дальнейшем оперировать я буду этими уровнями, от которых зависят различные области видимости.
1. Тестовый прогон - Execution
Запуск определенного набора тестов

2. Спецификация - Spec
Тестовый класс. В cucumber - это Feature

3. Контейнер теста - Top Level Test
Сценарий верхнего уровня в Спецификации. В cucumber - это Scenario

4. Шаг теста - Nested Test
Шаг в сценарии, который начинается с ключевого слова. 
Ключевое слово обозначает этап: подготовка (Дано), воздействие (Когда), проверка ожидаемой реакции (Тогда).
В cucumber - это Step

5. Вложенные Шаги - Nested Step
Это любая дополнительная информация о произведенных действиях, например аннотация allure `@Step`. 
В рамках описания сценария эти шаги не несут нагрузки — они нужны для отчета, для отладки, для выяснения причин ошибки. 
Kotest позволяет создавать любую вложенность, но в данном подходе мы ограничиваемся `4 - Шаг теста - Nested Test` - дальнейшая вложенность воспринимается как шаги для отчета. 

С точки зрения Форматирования теста и Review интерес представляют уровни **1** - **4**.

В Cucumber есть сущность Структура Сценария (Scenario Template) - это реализация Data Driven. 
В Kotest уровень `3. Контейнер теста - Top Level Test`, также может являться Структурой Сценария — то есть помножиться на наборы тестовых данных.    

##### Превращаем требования в сценарий
Допустим мы тестируем REST API сервиса и имеются требования. 
Не известно, как мы будем отправлять запросы, как получать, десериализовывать и проверять, но сейчас это не нужно. 

Пишем шаблон реализации:
```kotlin
open class KotestFirstAutomatedTesting : FreeSpec() {

    private companion object {
        private val log = LoggerFactory.getLogger(KotestFirstAutomatedTesting::class.java)
    }
    
    init {
        "Scenario. Single case" - {
            val expectedCode = 200

            "Given server is up" { }

            "When request prepared and sent" { }

            "Then response received and has $expectedCode code" { }
        }
    }
}
```
_Очень похоже на Сценарии в Cucumber_
Во первых стоит обратить внимание, что здесь нет понятия `тестовый класс`, а есть `спецификация` (`FreeSpec`). И это не спроста.
Вспоминаем, что Kotlin DSL - это type-safe builder, а значит при запуске наши тесты сначала формируют дерево тестов / тестовых контейнеров / pre и after функций / вложенных шагов умноженных на наборы тестовых данных.
Отмечу использование интерполяции строк в имени шага `"Then response received and has $expectedCode code"`

##### Принцип работы DSL
1. Контейнер теста.
> _**Используется минус после названия** Важно его не пропускать

Наш тест наследуется от класса `FreeSpec`, в свою очередь он реализует `FreeSpecRootScope`: 
```kotlin 
abstract class FreeSpec(body: FreeSpec.() -> Unit = {}) : DslDrivenSpec(), FreeSpecRootScope
```

В `FreeSpecRootScope` для класса `String` переопределяется оператор `-`:
```kotlin
infix operator fun String.minus(test: suspend FreeScope.() -> Unit) { }
```
Соответсвенно запись `"string" - { }` вызывает этот метод, передает внутрь функциональный тип с контекстом `FreeScope` и добавляет в дерево тестов Тест контейнер.

2. Шаги теста
В том же интерфейсе `FreeSpecRootScope` для класса `String` переопределяется оператор вызова `invoke`
```kotlin
infix operator fun String.invoke(test: suspend TestContext.() -> Unit) { }
```
Запись `"string" { }` является вызовом функции расширения с аргументом функционального типа с контекстом `TestContext`, а так как для лямбд круглые скобки можно опускать, то получается такая конструкция.
В базовом классе `FreeSpec` имеется переопределенный `infix` оператор 'минус' в виде функции расширения для String.
То есть запись `"test" - { }` вызывает функцию расширения `String.minus(test: suspend FreeScope.() -> Unit)` куда в качестве единственного аргумента передается лямбда нашего теста.

##### Реализация теста и проверок
```
init {
        "Scenario. Single case" - {

            //region Variables
            val expectedCode = 200
            val testEnvironment = Server()
            val tester = Client()
            //endregion

            "Given server is up" {
                testEnvironment.start()
            }

            "When request prepared and sent" {
                val request = Request()
                tester.send(request)
            }
            
            lateinit var response: Response
            "Then response received" {
                response = tester.receive()
            }

            "And has $expectedCode code" {
                response.code shouldBe expectedCode
            }
        }
    }
```
Поясню некоторые момент и мотивацию
1. Константы для конкретного сценария определены прямо в блоке и окружены конструкцией Idea для сворачивания
2. Для обмена информацией между шагами приходится использовать переменные типа `lateinit var response: Response`, определенные непосредственно перед блоком, в котором они инициализируются

#### Kotest Assertions и Matchers
Зависимость `testImplementation "io.kotest:kotest-assertions-core:$kotestVersion"` добавит все необходимое для реализации всех необходимых проверок в тестах.
Также есть возможность расширять ее и добавлять свои комплексные Matcher-ы, а также использовать уже готовые расширения.
См. документацию [**kotest-assertions**](https://kotest.io/assertions/) и список доступных [проверок из коробки](https://kotest.io/matchers/core/)  

```kotlin
"And has $expectedCode code" {
    assertSoftly {
        response.asClue {
            it.code shouldBe expectedCode
            it.body.shouldNotBeBlank()
        }
    }
    val assertion = assertThrows<AssertionError> {
        assertSoftly {
            response.asClue {
                it.code shouldBe expectedCode + 10
                it.body.shouldBeBlank()
            }
        }
    }
    assertion.message shouldContain "The following 2 assertions failed"
    log.error("Expected assertion", assertion)
}
```

1. **`assertSoftly { code }`**
Soft Assert из библиотеки assertions `Kotest` - выполнит блок кода полностью и сформирует сообщение со всеми ошибками.
2. **`response.asClue { }`** 
_MUST HAVE_ для проверок в тестах. Scope функция kotlin `asClue` - при возникновении ошибки добавит в сообщение строковое представление **всего** объекта `response`
3. Matcher-ы
Matchers от `Kotest` - отличная расширяемая библиотека проверок, полностью покрывает базовые потребности.
`shouldBe` - infix версия проверки на равенство.
`shouldBeBlank` - не infix (т.к. нет аргумента) проверка на пустоту строки. [Ссылка на полный список](https://kotest.io/matchers/core/)  
4. `assertThrows<AssertionError>` - статическая функция расширенной для Котлина библиотеки Junit5
```kotlin
inline fun <reified T : Throwable> assertThrows(noinline executable: () -> Unit)
```
Выполняет блок, проверяет тип ожидаемого Исключения и возвращает его для дальнейших проверок

#### Добавляем pre / after функции

Все вызовы `beforeSpec` / `afterSpec` / `beforeTest` / `afterTest` - это функции с одним аргументом функционального типа: `fun beforeTest(f: BeforeTest)` с алисом типа `typealias BeforeTest = suspend (TestCase) -> Unit`

#### Делаем тест Data Driven

А теперь добавим сюда data provider:
```kotlin

```
_Выглядит довольно просто, а главное понятно_


#### Выводы после первого знакомства

#### Планы
В планах написание следующих частей, которые покроют тему 'Kotlin. Автоматизация тестирования', темы:
- Kotest. Расширения, конфигурирование проекта, спецификации и тестов, тэги и фабрики тестов
- Spring Test. Интеграция с Kotest. Конфигурирование тестового контекста и контроль жизненного цикла бинов.
- Ожидания Awaitility. Retrofit для тестирования API. Работа c БД через Spring Data Jpa. 
- Gradle. Масштабируемая и распределенная структура множества проектов авто-тестов.
- Управление окружением. TestContainers, gradle compose plugin, kubernetes java api + helm