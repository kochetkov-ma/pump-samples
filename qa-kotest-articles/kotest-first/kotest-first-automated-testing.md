Kotlin. Автоматизация тестирования (часть 1). Kotest: Начало 
======

TODO:: Сюда картина Kotest

Более 5 лет занимаясь автоматизацией тестирования на Java я перепробовал множество подходов и технологий.
Начиналось все с 'голого' Junit + Selenium + RestAssured, далее вместо Junit пробовал TestNG, потом в стеке появились отчеты Allure.
Были и проекты, где использовались платные версии HP Unified Functional Testing, HP LeanFT, IBM Rational Functional. На замену Selenium пришел Selenoid, а для тестирования микро-сервисов TestContainers.
Помню удачный опыт использования очень интересного Фреймворка - Groovy Spock. 
Основная цель поисков и изучения новых технологий — это в идеале найти, но как правило найти и доработать под себя один Фреймворк или несколько отдельных технологий и все это объединить в единый подход, который обеспечит:
- быстрый старт для нового QA
- хорошую документацию
- минимальную дублируемость кода
- читаемость кода тестов
- понятные отчеты о результате
- масштабируемость и надежность самого инструмента
- удобство работы большой командой или множеством мелких
- раньше была острая необходимость в параллельности, но сейчас в эпоху облачных ресурсов, контейнерезации и оркестрации это качество отодвинулось на второй план

До недавнего времени (и наверное остается по сей день для меня) оптимальный набор инструментов для организации автоматизации функционального e2e или интеграционного тестирования является такой набор:
1. BDD подход основанный на Cucumber
2. Отдельный проект отведенный под шаги со своими unit-тестами
3. Selenide + самописный PageFactory 
4. Retrofit для тестирования API
5. TestContainers для контроля отдельных контейнеров (либо клиент для Kubernetes)
6. Allure отчеты
7. Spring Core для DI, контроля областей видимости и конфигурирования
8. Spring Data JPA для взаимодействия с БД
9. Сборка всего этого дела Gradle-ом
> _**Естественно, это актуально для штата более 2-ух QA** Для меньших команд действуют совсем другие правила_ 

Этот набор позволяет писать feature файлы практически не работая с Java кодом — соответсвенно, проще найти QA специалиста подходящего уровня. 
А на роль поддержки / модификации и создания новых шагов достаточно нескольких разработчиков или сильный QA. 
Естественно у этого подхода есть определенные минусы и большинство знают о них (особенно ненавистники BDD) и эти минусы довольно существенны, хотя и приемлимы, если с ними правильно бороться. 

**А теперь к сути!** Очередной мой новый проект оказался на **Kotlin**, и передо мной встал выбор: продолжать следовать проверенной тактике или же немного 'переобуться' 
и попробовать писать тесты в виде кода используя довольно молодой Фреймворк, написанный на Kotlin для создания и запуска тестов **Kotest** (в прошлом Kotlin Test).
Ну и как не сложно догадаться выбор пал на второй вариант! В итоге, забегая вперед, сам **Kotest** и вариант стиля, который был выбран мне очень понравились по эффективности, лаконичности и простоте.
А так как обзоров и статей в принципе об автоматизации на **Kotlin** и **Kotest** в частности прямо скажем немного, то я посчитал хорошей идеей написать цикл статей про непосредственно использование самого Фреймворка, 
а также об организации проекта, сборке, запуске и сопутствующих технологиях. По итогу должен получится полноценный мануал — как создать систему или даже эко-систему автоматизации функционального тестирования на языке **Kotlin** и платформе **Kotest**.

Минусы
------
Сходу определимся по глобальным минусам и учтем, что проект быстро развивается. Те проблемы, что есть в актуальной на время написания статьи версии `4.2.3` уже могут быть исправлены в свежих версиях.

И первым очевидным минусом является очень быстрое изменение минорных и мажорных версий. Еще в марте 2020 фреймворк назывался `KotlinTest`, и в 4 версии поменял название всех пакетов, потерял совместимость с плагином Idea и стал именоваться `Kotest`, а также стал мульти-платформенным.
При переходе с версии 4.0.7 на 4.1 перестали работать расширения, написанные для 4.0.7, а также сменились названия базовых модулей и много чего еще, то есть принцип семантического версионирования нарушился при переходе с `4.0` на `4.1`.
Это немыслимо для Java мира — это что-то из JS.
У инструмента пока небольшое комьюнити. 
В пользу широкого функционала иногда приносится в жертву продуманный дизайн. 
Не все предоставляемые стили написания тестов одинаково работают и отображаются в отчете. 
На текущий момент не корректно отображаются в отчетах data-driven и property-based тесты.
Шаблоны и фабрики тестов работают не как ожидается. 
Встроенное расширение allure совсем никуда не годится (к примеру, оно пытается обрабатывать аннотации, которыми в принципе невозможно аннотировать тестовые DSL методы).
Однако ни одного критического или блокирующего дефекта я не встречал.


Почему Kotest
------
Множество разработчиков на Kotlin не особо заморачиваются с выбором тестового фреймворка и продолжают использовать Junit4 или Junit5. 
Для них тесты — это как правило класс, помеченный аннотацией `@SpringBootTest` набор методов с аннотацией `@Test` возможно методы before и beforeClass с соответствующими аннотациями.
Для полноценных функциональных e2e тестов этого недостаточно. Наша цель — это написание понятных тестов на основе требований, удобная организация проверок, тестовых данных и отчетности.
Так вот `Kotest` позволяет:
- создавать крайне понятные тесты в BDD стиле с помощью Kotlin DSL и функций расширения,
- легко создавать data driven тесты в функциональном стиле
- также с помощью DSL определять действия перед тестом и тестовым классом и после них.
- определить действия на уровне всего прогона (фича, которой нет явно в junit)
- использовать встроенный крайне удобные assertions
- удобное конфигурирование тестовых классов и тестового проекта из кода
и много чего еще, см. [полную документацию в Github](https://github.com/kotest/kotest/blob/master/doc/reference.md) 

Какой стиль выбрать? 
------
Kotest дает возможность выбора между несколькими вариантами DSL для формирования структуры тестов.
Самый базовый и простой [String Spec](https://github.com/kotest/kotest/blob/master/doc/styles.md#string-spec) - идеально подойдет для написания юнит-тестов с одним уровнем вложенности шагов.
Но нам нужно, что-то посложнее. 
Не буду долго рассуждать. 
Сразу скажу, что после долгих экспериментов я остановился на стиле [FreeSpec](https://github.com/kotest/kotest/blob/master/doc/styles.md#free-spec).

#### Начинаем создавать тест
Вот пример теста без реализации:
```kotlin

```
_Очень похоже на Сценарии в Cucumber_
Во первых стоит обратить внимание, что здесь нет понятия `тестовый класс`, а есть `спецификация` (`FreeSpec`). И это не спроста.
Вспоминаем, что Kotlin DSL - это type-safe builder, а значит при запуске наши тесты сначала формируют дерево тестов / тестовых контейнеров / pre и after функций / вложенных шагов умноженных на наборы тестовых данных.
Поэтому в дальнейшем будем называть тестовый класс **Спецификацией** (`Spec`) - это не новый подход, например фреймворк Groovy Spock работает похожим образом. 

#### Поясню кратко принцип работы:
В базовом классе `FreeSpec` имеется переопределенный `infix` оператор 'минус' в виде функции расширения для String.
То есть запись `"test" - { }` вызывает функцию расширения `String.minus(test: suspend FreeScope.() -> Unit)` куда в качестве единственного аргумента передается лямбда нашего теста
Далее следуют вложенные шаги теста, написанные в BDD стиле. 
`"Given " { }` вызывает `infix` функцию расширения `String.invoke(test: suspend TestContext.() -> Unit)` и т.д.
Все вызовы `beforeSpec` / `afterSpec` / `beforeTest` / `afterTest` - это функции с одним аргументом функционального типа: `fun beforeTest(f: BeforeTest)` с алисом типа `typealias BeforeTest = suspend (TestCase) -> Unit`

#### Добавляем pre / after функции

#### Делаем тест Data Driven

А теперь добавим сюда data provider:
```kotlin

```
_Выглядит довольно просто, а главное понятно_



#### Теперь используем встроенные assertions

#### Выводы после первого знакомства

